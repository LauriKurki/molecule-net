import math
import torch
from torch import nn
from torch.nn import functional as F

import escnn
from escnn import nn as enn

from molnet.escnn_models import InnerBatchNorm3D

from typing import Union, Callable, Tuple


def _get_padding(kernel_size):
    padding = [(kernel_size-1) // 2]*3
    return tuple(padding)


class EqConv3d(enn.EquivariantModule):
    """
    Equivariant Pytorch 3D convolutional block.

    Args:
        gspace (`escnn.gspaces.GSpace`): The space that describes
            the symmetries the features should have.
        ch_in (int): number of independent feature fields in the input.
        ch_out (int): number of independent feature fields in the output.
        kernel_size (int): Size of convolution kernel.
        padding (int): Amount of padding applied to the input.
        scalar_input (boolean): Input transforms as a trivial representation.
            True for first layer of model assuming image input.
        scalar_output (boolean): Output transforms as a trivial representation.
            True for last layer of model assuming image output.
        res_connection (boolean): Applies residual connection over the block.
    """
    def __init__(
        self,
        gspace: escnn.gspaces.GSpace,
        ch_in: int,
        ch_out: int,
        kernel_size: int = 3,
        padding: Union[str, int] = 'same',
        scalar_input: bool = False,
        scalar_output: bool = False,
        activation: Callable[[enn.GeometricTensor], enn.GeometricTensor] = enn.ReLU,
    ):
        super(EqConv3d, self).__init__()

        assert isinstance(scalar_input, bool)
        assert isinstance(scalar_output, bool)

        if isinstance(padding, str):
            if padding == 'same':
                padding = _get_padding(kernel_size)
            else:
                raise ValueError('invalid padding')

        elif isinstance(padding, int):
            padding = padding

        if scalar_input:
            c_in = enn.FieldType(gspace, ch_in*[gspace.trivial_repr])
        else:
            c_in = enn.FieldType(gspace, ch_in*[gspace.regular_repr])

        if scalar_output:
            c_out = enn.FieldType(gspace, ch_out*[gspace.trivial_repr])
        else:
            c_out = enn.FieldType(gspace, ch_out*[gspace.regular_repr])

        self.in_type = c_in
        self.out_type = c_out

        self.conv1 = enn.R3Conv(c_in, c_out, kernel_size=kernel_size, padding=padding)
        self.bn1 = InnerBatchNorm3D(c_out)

        self.conv2 = enn.R3Conv(c_out, c_out, kernel_size=kernel_size, padding=padding)
        self.bn2 = InnerBatchNorm3D(c_out)

        self.res_conv = enn.R3Conv(c_in, c_out, kernel_size=1, padding=0)

        self.activation = activation(c_out)


    def forward(self, x):
        res = x

        x = self.conv1(x)
        x = self.bn1(x)
        x = self.activation(x)

        x = self.conv2(x)
        x = self.bn2(x)

        if x.tensor.shape != res.tensor.shape:
            res = self.res_conv(res)

        x = self.activation(x + res)
        return x


    def evaluate_output_shape(self, input_shape: Tuple[int, ...]) -> Tuple[int, ...]:
        r"""
        Compute the shape the output tensor which would be generated by this module when a tensor with shape
        ``input_shape`` is provided as input.

        Args:
            input_shape (tuple): shape of the input tensor

        Returns:
            shape of the output tensor

        """
        return self.conv1.evaluate_output_shape(input_shape)
        